package data

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"time"

	"adcentra.ai/internal/db/sqlc"
	i18n "adcentra.ai/internal/i18n"
	"adcentra.ai/internal/validator"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	goi18n "github.com/nicksnyder/go-i18n/v2/i18n"
)

const (
	ScopeActivation     = "activation"
	ScopeAuthentication = "authentication"
	ScopePasswordReset  = "password-reset"
	ScopeRefresh        = "refresh"
)

type Token struct {
	Base

	Plaintext string             `json:"token"`
	Hash      []byte             `json:"-"`
	UserID    int64              `json:"-"`
	Expiry    pgtype.Timestamptz `json:"expiry"`
	Scope     string             `json:"-"`
}

func (token *Token) fromSQLCToken(t sqlc.Token) {
	*token = Token{
		Base: Base{
			CreatedAt: t.CreatedAt,
			UpdatedAt: t.UpdatedAt,
		},
		Hash:   t.Hash,
		UserID: t.UserID,
		Expiry: t.Expiry,
		Scope:  t.Scope,
	}
}

func generateToken(userID int64, ttl time.Duration, scope string) *Token {
	// Set the Plaintext field to be a random token generated by rand.Text()
	token := &Token{
		Plaintext: rand.Text(),
		UserID:    userID,
		Expiry:    pgtype.Timestamptz{Time: time.Now().Add(ttl), Valid: true},
		Scope:     scope,
	}

	// Generate a SHA-256 hash of the plaintext token string. This will be the value
	// that we store in the `hash` column of our database table. Note that the
	// sha256.Sum256() function returns an *array* of length 32, so to make it easier to
	// work with we convert it to a slice using the [:] operator before storing it.
	hash := sha256.Sum256([]byte(token.Plaintext))
	token.Hash = hash[:]

	return token
}

func ValidateTokenPlaintext(v *validator.Validator, localizer *goi18n.Localizer, tokenPlaintext string) {
	v.Check(tokenPlaintext != "", "token", i18n.LocalizeMessage(localizer, "TokenMustBeProvided", nil))
	v.Check(len(tokenPlaintext) == 26, "token", i18n.LocalizeMessage(localizer, "TokenMustBe26BytesLong", nil))
}

type TokenModel struct {
	pool    *pgxpool.Pool
	queries *sqlc.Queries
}

func (m TokenModel) New(ctx context.Context, userID int64, ttl time.Duration, scope string) (*Token, error) {
	token := generateToken(userID, ttl, scope)

	err := m.Insert(ctx, token)
	return token, err
}

func (m TokenModel) Insert(ctx context.Context, token *Token) error {
	t, err := m.queries.InsertToken(ctx, sqlc.InsertTokenParams{
		Hash:   token.Hash,
		UserID: token.UserID,
		Expiry: token.Expiry,
		Scope:  token.Scope,
	})
	if err != nil {
		return err
	}

	token.CreatedAt = t.CreatedAt
	token.UpdatedAt = t.UpdatedAt
	return nil
}

func (m TokenModel) DeleteAllForUser(ctx context.Context, scope string, userID int64) error {
	return m.queries.DeleteAllForUser(ctx, sqlc.DeleteAllForUserParams{
		Scope:  scope,
		UserID: userID,
	})
}

func (m TokenModel) DeleteAllForUserExcept(ctx context.Context, scope string, userID int64, hash []byte) error {
	return m.queries.DeleteAllForUserExceptHash(ctx, sqlc.DeleteAllForUserExceptHashParams{
		Scope:  scope,
		UserID: userID,
		Hash:   hash,
	})
}

func (m TokenModel) DeleteByHash(ctx context.Context, hash []byte) error {
	return m.queries.DeleteByHash(ctx, hash)
}

func (m TokenModel) DeleteExpiredTokens(ctx context.Context) error {
	return m.queries.DeleteExpiredTokens(ctx)
}
